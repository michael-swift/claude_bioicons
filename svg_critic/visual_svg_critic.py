#!/usr/bin/env python3
"""
Visual SVG Critic - A vision-based SVG analysis and improvement system.

This tool uses a combination of SVG rendering and visual analysis to provide
more human-like feedback on SVG designs.
"""

import os
import sys
import json
import argparse
import shutil
import tempfile
import xml.etree.ElementTree as ET
from pathlib import Path
import subprocess
import base64

# For a full implementation, you would use:
# import cairosvg  # For SVG rendering
# import anthropic  # For Claude API access

class VisualSVGCritic:
    """
    A vision-based SVG critic that simulates analyzing rendered images.
    """
    
    def __init__(self, svg_path):
        """
        Initialize with path to SVG file.
        
        Args:
            svg_path: Path to the SVG file to analyze
        """
        self.svg_path = svg_path
        self.parse_svg()
        
        # Create a temporary directory for outputs
        self.temp_dir = tempfile.mkdtemp()
        self.rendered_image_path = os.path.join(
            self.temp_dir, 
            f"{Path(svg_path).stem}_rendered.png"
        )
    
    def parse_svg(self):
        """Parse SVG file and extract basic information."""
        # First fix any malformed SVG
        self._fix_svg_file()
        
        # Define SVG namespaces for proper parsing
        namespaces = {
            'svg': 'http://www.w3.org/2000/svg',
            'xlink': 'http://www.w3.org/1999/xlink'
        }
        
        # Register namespaces for ElementTree
        for prefix, uri in namespaces.items():
            ET.register_namespace(prefix, uri)
        
        # Now parse the fixed SVG
        self.tree = ET.parse(self.svg_path)
        self.root = self.tree.getroot()
        
        # Extract basic SVG properties
        self.width = float(self.root.get('width', '800'))
        self.height = float(self.root.get('height', '600'))
        
        # Extract quadrants for region-based analysis
        self.quadrants = {
            'q1': {'name': 'Upper Left', 'x1': 0, 'y1': 0, 'x2': self.width/2, 'y2': self.height/2},
            'q2': {'name': 'Upper Right', 'x1': self.width/2, 'y1': 0, 'x2': self.width, 'y2': self.height/2},
            'q3': {'name': 'Lower Right', 'x1': self.width/2, 'y1': self.height/2, 'x2': self.width, 'y2': self.height},
            'q4': {'name': 'Lower Left', 'x1': 0, 'y1': self.height/2, 'x2': self.width/2, 'y2': self.height}
        }
    
    def _fix_svg_file(self):
        """
        Fix common issues in SVG files generated by Claude.
        """
        try:
            with open(self.svg_path, 'r') as f:
                svg_content = f.read()
            
            modified = False
            
            # Fix issue with multiple XML declarations
            if svg_content.count("<?xml") > 1:
                # Keep only the first XML declaration
                first_decl_end = svg_content.find("?>") + 2
                second_decl_start = svg_content.find("<?xml", first_decl_end)
                
                if second_decl_start > 0:
                    # Find the <svg> tag after the second XML declaration
                    svg_tag_start = svg_content.find("<svg", second_decl_start)
                    if svg_tag_start > 0:
                        # Combine first declaration with content after <svg>
                        fixed_content = svg_content[:first_decl_end] + "\n" + svg_content[svg_tag_start:]
                        modified = True
                        svg_content = fixed_content
                        print(f"Fixed multiple XML declarations in {self.svg_path}")
            
            # Remove any explanatory text before <?xml
            if not svg_content.startswith("<?xml"):
                xml_start = svg_content.find("<?xml")
                if xml_start > 0:
                    svg_content = svg_content[xml_start:]
                    modified = True
                    print(f"Removed text before XML declaration in {self.svg_path}")
            
            # Write back the fixed content if modified
            if modified:
                with open(self.svg_path, 'w') as f:
                    f.write(svg_content)
                    
        except Exception as e:
            print(f"Error fixing SVG file: {str(e)}")
            # Continue with parsing attempt even if fixing fails
    
    def render_svg(self):
        """
        Render SVG to image for visual analysis.
        
        In a full implementation, this would use a library like CairoSVG.
        For this prototype, we'll attempt to use a command-line tool if available,
        or otherwise just simulate the rendering step.
        """
        try:
            # Try to use rsvg-convert if available
            subprocess.run([
                'rsvg-convert',
                '-o', self.rendered_image_path,
                self.svg_path
            ], check=True)
            print(f"Rendered SVG to: {self.rendered_image_path}")
            return True
        except (subprocess.SubprocessError, FileNotFoundError):
            print("Warning: Could not render SVG (rsvg-convert not available)")
            print("Simulating rendering step...")
            # Create an empty file to simulate rendering
            Path(self.rendered_image_path).touch()
            return False
    
    def analyze_visual(self):
        """
        Analyze the rendered image visually.
        
        In a full implementation, this would use the Claude Vision API.
        For this prototype, we'll simulate the analysis based on quadrants.
        """
        # Simulate visual analysis
        visual_feedback = {
            'elements_by_region': {
                'Upper Left': self._count_elements_in_quadrant('q1'),
                'Upper Right': self._count_elements_in_quadrant('q2'),
                'Lower Right': self._count_elements_in_quadrant('q3'),
                'Lower Left': self._count_elements_in_quadrant('q4')
            },
            'visual_issues': []
        }
        
        # Add simulated visual issues based on SVG structure
        # Find text elements and check their size
        small_text = []
        for elem in self.root.iter('{http://www.w3.org/2000/svg}text'):
            font_size = elem.get('font-size', '12')
            # Extract numeric part of font-size
            try:
                size = float(''.join(c for c in font_size if c.isdigit() or c == '.'))
                if size < 10:
                    small_text.append({
                        'id': elem.get('id', '(unknown)'),
                        'content': elem.text or '(empty)',
                        'size': size
                    })
            except ValueError:
                pass
        
        if small_text:
            visual_feedback['visual_issues'].append({
                'type': 'readability',
                'description': f"Found {len(small_text)} text elements with small font size (< 10px)",
                'elements': small_text,
                'severity': 'medium'
            })
        
        # Check for quadrant imbalance
        counts = list(visual_feedback['elements_by_region'].values())
        if max(counts) > 2 * min(counts):
            max_region = max(visual_feedback['elements_by_region'], key=visual_feedback['elements_by_region'].get)
            min_region = min(visual_feedback['elements_by_region'], key=visual_feedback['elements_by_region'].get)
            
            visual_feedback['visual_issues'].append({
                'type': 'balance',
                'description': f"Visual imbalance: {max_region} has {max(counts)} elements while {min_region} has only {min(counts)}",
                'severity': 'medium'
            })
        
        return visual_feedback
    
    def _count_elements_in_quadrant(self, quadrant):
        """Count elements in a specific quadrant."""
        count = 0
        q = self.quadrants[quadrant]
        
        for elem in self.root.iter():
            # For simplicity, only count certain element types
            if elem.tag.endswith('}rect') or elem.tag.endswith('}circle') or \
               elem.tag.endswith('}path') or elem.tag.endswith('}text'):
                
                # Try to determine element position
                x, y = self._get_element_position(elem)
                
                # Check if position is in quadrant
                if q['x1'] <= x < q['x2'] and q['y1'] <= y < q['y2']:
                    count += 1
        
        return count
    
    def _get_element_position(self, elem):
        """Determine approximate position of an element."""
        tag = elem.tag.split('}')[-1]
        
        if tag == 'rect':
            x = float(elem.get('x', '0'))
            y = float(elem.get('y', '0'))
            width = float(elem.get('width', '0'))
            height = float(elem.get('height', '0'))
            return x + width/2, y + height/2
            
        elif tag == 'circle':
            cx = float(elem.get('cx', '0'))
            cy = float(elem.get('cy', '0'))
            return cx, cy
            
        elif tag == 'text':
            x = float(elem.get('x', '0'))
            y = float(elem.get('y', '0'))
            return x, y
        
        # For other elements, try common attributes or default to (0,0)
        x = elem.get('x', elem.get('cx', '0'))
        y = elem.get('y', elem.get('cy', '0'))
        
        try:
            return float(x), float(y)
        except (ValueError, TypeError):
            return 0, 0
    
    def analyze_structure(self):
        """
        Analyze SVG code structure for issues and improvement opportunities.
        
        This is a more reliable analysis since we have direct access to the SVG code.
        """
        structure_feedback = {
            'code_issues': [],
            'improvement_opportunities': []
        }
        
        # Check for missing ids
        missing_ids = []
        for i, elem in enumerate(self.root.iter()):
            if elem.tag.endswith(('}rect', '}circle', '}path', '}g')) and not elem.get('id'):
                missing_ids.append({
                    'element_type': elem.tag.split('}')[-1],
                    'position': i
                })
        
        if missing_ids:
            structure_feedback['code_issues'].append({
                'type': 'maintainability',
                'description': f"Found {len(missing_ids)} elements without id attributes",
                'elements': missing_ids[:5],  # Just show first 5
                'count': len(missing_ids),
                'severity': 'low'
            })
        
        # Check for color consistency
        colors = {}
        for elem in self.root.iter():
            fill = elem.get('fill')
            if fill and fill not in ('none', 'transparent'):
                colors[fill] = colors.get(fill, 0) + 1
                
        # Standard palette from Bioicons guidelines
        standard_palette = ['#19aeff', '#ff4141', '#ffc022', '#5dbb63', '#333333']
        non_standard_colors = {c: count for c, count in colors.items() 
                               if c.lower() not in [s.lower() for s in standard_palette]}
        
        if len(non_standard_colors) > 3:
            structure_feedback['code_issues'].append({
                'type': 'color_harmony',
                'description': f"Using {len(non_standard_colors)} non-standard colors",
                'colors': list(non_standard_colors.keys())[:5],  # Just show first 5
                'count': len(non_standard_colors),
                'severity': 'medium'
            })
            
            structure_feedback['improvement_opportunities'].append({
                'type': 'color_standardization',
                'description': "Standardize colors to use Bioicons palette",
                'implementation': "Replace non-standard colors with the closest match from standard palette",
                'standard_palette': standard_palette
            })
        
        return structure_feedback
    
    def evaluate(self):
        """
        Perform complete evaluation of the SVG from both visual and structural perspectives.
        
        Returns:
            Dictionary with evaluation results
        """
        # Step 1: Render SVG to image
        rendering_successful = self.render_svg()
        
        # Step 2: Visual analysis (simulated in this prototype)
        visual_feedback = self.analyze_visual()
        
        # Step 3: Structure analysis
        structure_feedback = self.analyze_structure()
        
        # Step 4: Integrate feedback
        overall_feedback = self._integrate_feedback(visual_feedback, structure_feedback)
        
        # Clean up temporary files
        # shutil.rmtree(self.temp_dir)
        
        return overall_feedback
    
    def _integrate_feedback(self, visual_feedback, structure_feedback):
        """Combine visual and structural feedback into a cohesive assessment."""
        # Count issues by severity
        issues_count = {
            'critical': 0,
            'high': 0,
            'medium': 0,
            'low': 0
        }
        
        all_issues = []
        
        # Process visual issues
        for issue in visual_feedback['visual_issues']:
            severity = issue.get('severity', 'medium').lower()
            if severity in issues_count:
                issues_count[severity] += 1
            all_issues.append({
                'source': 'visual',
                'type': issue['type'],
                'description': issue['description'],
                'severity': severity
            })
        
        # Process structural issues
        for issue in structure_feedback['code_issues']:
            severity = issue.get('severity', 'medium').lower()
            if severity in issues_count:
                issues_count[severity] += 1
            all_issues.append({
                'source': 'structure',
                'type': issue['type'],
                'description': issue['description'],
                'severity': severity
            })
        
        # Calculate overall score (weighted by severity)
        severity_weights = {
            'critical': 0.4,
            'high': 0.3,
            'medium': 0.2,
            'low': 0.1
        }
        
        total_issues = sum(issues_count.values())
        if total_issues == 0:
            overall_score = 100
        else:
            weighted_sum = sum(issues_count[sev] * severity_weights[sev] for sev in issues_count)
            # Convert issues count to a 0-100 score (where 0 issues = 100)
            overall_score = max(0, 100 - (weighted_sum * 100 / sum(severity_weights.values())))
            overall_score = min(100, overall_score)  # Cap at 100
        
        return {
            'overall_score': round(overall_score),
            'visual_feedback': visual_feedback,
            'structure_feedback': structure_feedback,
            'issues_count': issues_count,
            'all_issues': all_issues,
            'improvement_opportunities': structure_feedback['improvement_opportunities']
        }
    
    def suggest_improvements(self, feedback):
        """
        Generate specific suggestions for improving the SVG.
        
        Args:
            feedback: Integrated feedback from evaluate()
            
        Returns:
            List of improvement suggestions
        """
        suggestions = []
        
        # Add suggestions based on visual issues
        for issue in feedback['visual_feedback']['visual_issues']:
            if issue['type'] == 'readability':
                suggestions.append({
                    'title': 'Improve Text Readability',
                    'description': 'Increase font size for small text elements',
                    'implementation': 'find small text elements and increase their font-size to at least 12px'
                })
            
            elif issue['type'] == 'balance':
                suggestions.append({
                    'title': 'Improve Visual Balance',
                    'description': 'Redistribute elements more evenly across quadrants',
                    'implementation': 'move some elements from the most populated quadrant to the least populated one'
                })
        
        # Add suggestions from structure feedback
        suggestions.extend([{
            'title': opp['description'],
            'description': opp.get('implementation', ''),
            'type': opp['type']
        } for opp in feedback['improvement_opportunities']])
        
        return suggestions
        
    def apply_improvements(self, input_svg_path, feedback, output_svg_path):
        """
        Apply automated improvements to the SVG based on feedback.
        
        Args:
            input_svg_path: Path to the input SVG file
            feedback: Integrated feedback from evaluate()
            output_svg_path: Path to save the improved SVG
            
        Returns:
            Dictionary with information about improvements made
        """
        return self._apply_improvements(input_svg_path, feedback, output_svg_path)
        
    def _apply_improvements(self, input_svg_path, feedback, output_svg_path):
        """
        Internal implementation of applying improvements to the SVG.
        
        Args:
            input_svg_path: Path to the input SVG file
            feedback: Integrated feedback from evaluate()
            output_svg_path: Path to save the improved SVG
            
        Returns:
            Dictionary with information about improvements made
        """
        # Parse SVG
        namespaces = {
            'svg': 'http://www.w3.org/2000/svg',
            'xlink': 'http://www.w3.org/1999/xlink'
        }
        
        # Register namespaces for ElementTree
        for prefix, uri in namespaces.items():
            ET.register_namespace(prefix, uri)
            
        tree = ET.parse(input_svg_path)
        root = tree.getroot()
        
        improvements = {
            'readability': [],
            'color_harmony': [],
            'visual_balance': [],
            'other': []
        }
        
        # 1. Fix small text
        for issue in feedback.get('all_issues', []):
            if 'text' in issue.get('description', '').lower() and 'small' in issue.get('description', '').lower():
                for elem in root.iter('{http://www.w3.org/2000/svg}text'):
                    font_size = elem.get('font-size', '')
                    if font_size:
                        # Extract numeric part
                        try:
                            size = float(''.join(c for c in font_size if c.isdigit() or c == '.'))
                            if size < 12:
                                elem.set('font-size', '12px')
                                improvements['readability'].append(
                                    f"Increased font size for text element with id={elem.get('id', '(unknown)')}"
                                )
                        except ValueError:
                            pass
        
        # 2. Standardize colors
        for opp in feedback.get('improvement_opportunities', []):
            if opp.get('type') == 'color_standardization':
                standard_palette = opp.get('standard_palette', ['#19aeff', '#ff4141', '#ffc022', '#5dbb63', '#333333'])
                color_map = {}
                
                # Find all non-standard colors
                for elem in root.iter():
                    fill = elem.get('fill')
                    if fill and fill not in ('none', 'transparent') and fill.lower() not in [s.lower() for s in standard_palette]:
                        # Simple mapping: hash the color to pick a standard one
                        if fill not in color_map:
                            color_map[fill] = standard_palette[hash(fill) % len(standard_palette)]
                
                # Apply color changes
                for elem in root.iter():
                    fill = elem.get('fill')
                    if fill in color_map:
                        elem.set('fill', color_map[fill])
                
                if color_map:
                    improvements['color_harmony'].append(
                        f"Standardized {len(color_map)} colors to match Bioicons palette"
                    )
        
        # Save improved SVG
        tree.write(output_svg_path, encoding='utf-8', xml_declaration=True)
        
        return {
            'input_path': input_svg_path,
            'output_path': output_svg_path,
            'improvements': improvements
        }

class MockClaudeAPI:
    """
    Mock implementation of Claude API for demonstration purposes.
    In a real implementation, this would call the actual Claude API.
    """
    
    @staticmethod
    def analyze_image(image_path, svg_code, prompt):
        """
        Simulate Claude analyzing an image.
        
        Args:
            image_path: Path to the rendered SVG image
            svg_code: The original SVG code
            prompt: Prompt for Claude's image analysis
            
        Returns:
            Simulated Claude analysis response
        """
        # Check if image exists
        if not os.path.exists(image_path) or os.path.getsize(image_path) == 0:
            return {
                "error": "Could not analyze image (rendering failed or not supported in this environment)"
            }
        
        # Parse SVG to extract some data for our simulated analysis
        try:
            tree = ET.parse(io.StringIO(svg_code))
            root = tree.getroot()
            
            # Count elements by type to simulate analysis
            element_counts = {}
            for elem in root.iter():
                tag = elem.tag.split('}')[-1]
                element_counts[tag] = element_counts.get(tag, 0) + 1
                
            # Simple "visual" analysis based on counts
            quadrants = ["upper left", "upper right", "lower left", "lower right"]
            most_elements = max(element_counts.values()) if element_counts else 0
            
            analysis = f"""
            I've analyzed the SVG diagram and here are my observations:
            
            1. The diagram appears to be a scientific workflow visualization with {sum(element_counts.values())} total elements.
            
            2. Visual Balance: The {quadrants[hash(str(element_counts)) % 4]} quadrant appears more densely populated.
            
            3. Color Usage: I notice {'consistent' if len(element_counts) < 10 else 'varied'} color usage across the diagram.
            
            4. Text Readability: Some text elements may be difficult to read at smaller sizes.
            
            5. Overall Structure: The diagram follows a {'clear' if most_elements < 30 else 'complex'} organizational structure.
            
            Suggestions for improvement:
            - Consider {'simplifying some elements' if most_elements > 20 else 'adding more contextual labels'}
            - {'Standardize colors for consistency' if len(element_counts) > 8 else 'Current color palette looks appropriate'}
            - {'Ensure all text is at least 12px for readability' if 'text' in element_counts and element_counts['text'] > 5 else ''}
            """
            
            return {
                "success": True,
                "analysis": analysis
            }
            
        except Exception as e:
            return {
                "error": f"Error simulating analysis: {str(e)}"
            }
    
    @staticmethod
    def improve_svg(svg_code, feedback):
        """
        Simulate Claude improving an SVG based on feedback.
        
        Args:
            svg_code: The original SVG code
            feedback: Feedback from visual and structural analysis
            
        Returns:
            Simulated improved SVG code
        """
        try:
            # Parse SVG
            tree = ET.parse(io.StringIO(svg_code))
            root = tree.getroot()
            
            # Apply simple improvements based on feedback
            improvements_made = []
            
            # 1. Fix small text (if mentioned in feedback)
            for issue in feedback.get('all_issues', []):
                if 'text' in issue.get('description', '').lower() and 'small' in issue.get('description', '').lower():
                    for elem in root.iter('{http://www.w3.org/2000/svg}text'):
                        font_size = elem.get('font-size', '')
                        if font_size and font_size.isdigit() and int(font_size) < 12:
                            elem.set('font-size', '12')
                            improvements_made.append(f"Increased font size for text element with id={elem.get('id', '(unknown)')}")
            
            # 2. Standardize colors (if mentioned in feedback)
            for opp in feedback.get('improvement_opportunities', []):
                if opp.get('type') == 'color_standardization':
                    standard_palette = opp.get('standard_palette', ['#19aeff', '#ff4141', '#ffc022', '#5dbb63', '#333333'])
                    color_changes = {}
                    
                    for elem in root.iter():
                        fill = elem.get('fill')
                        if fill and fill not in ('none', 'transparent') and fill not in standard_palette:
                            # Simple heuristic: replace with a standard color
                            new_color = standard_palette[hash(fill) % len(standard_palette)]
                            elem.set('fill', new_color)
                            color_changes[fill] = new_color
                    
                    if color_changes:
                        improvements_made.append(f"Standardized {len(color_changes)} colors to match Bioicons palette")
            
            # Generate improved SVG
            improved_svg = ET.tostring(root, encoding='unicode')
            
            return {
                "success": True,
                "improved_svg": improved_svg,
                "improvements": improvements_made
            }
            
        except Exception as e:
            return {
                "error": f"Error simulating improvements: {str(e)}"
            }

def generate_report(feedback, suggestions=None):
    """
    Generate a human-readable report from the feedback.
    
    Args:
        feedback: Integrated feedback from evaluate()
        suggestions: List of improvement suggestions
        
    Returns:
        Report as string
    """
    report = [
        "# Visual SVG Critic - Evaluation Report",
        "",
        f"## Overall Score: {feedback['overall_score']}/100",
        "",
        "## Issues Summary",
        f"- Critical: {feedback['issues_count']['critical']}",
        f"- High: {feedback['issues_count']['high']}",
        f"- Medium: {feedback['issues_count']['medium']}",
        f"- Low: {feedback['issues_count']['low']}",
        ""
    ]
    
    # Visual Feedback
    report.append("## Visual Analysis")
    
    # Element distribution
    report.append("### Element Distribution")
    for region, count in feedback['visual_feedback']['elements_by_region'].items():
        report.append(f"- {region}: {count} elements")
    report.append("")
    
    # Visual issues
    if feedback['visual_feedback']['visual_issues']:
        report.append("### Visual Issues")
        for issue in feedback['visual_feedback']['visual_issues']:
            report.append(f"- **{issue['type'].upper()}** ({issue['severity']}): {issue['description']}")
        report.append("")
    else:
        report.append("### Visual Issues\nNo visual issues detected!\n")
    
    # Structural Feedback
    report.append("## Structure Analysis")
    
    # Code issues
    if feedback['structure_feedback']['code_issues']:
        report.append("### Code Issues")
        for issue in feedback['structure_feedback']['code_issues']:
            report.append(f"- **{issue['type'].upper()}** ({issue['severity']}): {issue['description']}")
        report.append("")
    else:
        report.append("### Code Issues\nNo code issues detected!\n")
    
    # Improvement suggestions
    if suggestions:
        report.append("## Improvement Suggestions")
        for i, suggestion in enumerate(suggestions, 1):
            report.append(f"### {i}. {suggestion['title']}")
            report.append(f"{suggestion['description']}")
            report.append("")
    
    return "\n".join(report)

def main():
    """Main function to parse args and run the visual critic."""
    parser = argparse.ArgumentParser(description="Visual SVG Critic - Vision-based SVG analysis")
    parser.add_argument("svg_path", help="Path to the SVG file to analyze")
    parser.add_argument("--output", "-o", help="Path to save the report (default: stdout)")
    parser.add_argument("--improve", "-i", action="store_true", help="Generate improvement suggestions")
    args = parser.parse_args()
    
    try:
        # Verify the SVG exists
        if not os.path.isfile(args.svg_path):
            print(f"Error: SVG file not found at {args.svg_path}")
            return 1
        
        # Create critic and evaluate
        critic = VisualSVGCritic(args.svg_path)
        feedback = critic.evaluate()
        
        # Generate suggestions if requested
        suggestions = None
        if args.improve:
            suggestions = critic.suggest_improvements(feedback)
        
        # Generate report
        report = generate_report(feedback, suggestions)
        
        # Output report
        if args.output:
            with open(args.output, 'w') as f:
                f.write(report)
            print(f"Report saved to: {args.output}")
        else:
            print(report)
        
    except Exception as e:
        print(f"Error: {str(e)}")
        return 1
    
    return 0

if __name__ == "__main__":
    import io  # For StringIO in MockClaudeAPI
    sys.exit(main())